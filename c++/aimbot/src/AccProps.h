///----------------------------------------------------------------------------
///
/// File Name: AccProps.h
///
///----------------------------------------------------------------------------
///
/// Copyright 2002-2007 AOL LLC. All rights reserved.
/// This software contains valuable confidential and proprietary information of
/// AOL LLCÊand its use is subject to a license agreement.  Any unauthorized
/// modification, use, reproduction, transmission or distribution of this
/// software code is strictly prohibited.
///
///           A O L   L L C   C O N F I D E N T I A L
///
///----------------------------------------------------------------------------

#ifndef ACCPROPS_H
#define ACCPROPS_H

// C++ methods
#ifdef __cplusplus

extern "C"
{
// Due to the limitations on cpp-quoting within headers generated by midl
// and the strict template rules of gcc 4, we replicate this declaration here.
STDAPI AccVarChangeType(xp_variant* pvard, xp_variant* pvars, xp_vtype vt);
}

extern "C++" {

XP_BEGIN_NAMESPACE(AIMCC)

template <class T, class U>
HRESULT get_Property(T* p, U n, xp_variant* px)
{
    return p->get_Property(n, px);
}

template <class T, class U>
HRESULT get_Property(T* p, U n, xp_bool* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_BOOL);
    if (SUCCEEDED(hr))
        *px = (v.boolVal != VARIANT_FALSE);
    return hr;
}

template <class T, class U>
HRESULT get_Property(T* p, U n, xp_s32* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_I4);
    if (SUCCEEDED(hr))
        *px = v.lVal;
    return hr;
}

template <class T, class U>
HRESULT get_Property(T* p, U n, xp_u32* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_UI4);
    if (SUCCEEDED(hr))
        *px = v.ulVal;
    return hr;
}

template <class T, class U>
HRESULT get_Property(T* p, U n, xp_s64* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_CY);
    if (SUCCEEDED(hr))
        *px = v.cyVal.int64 / 10000;
    return hr;
}

template <class T, class U>
HRESULT get_Property(T* p, U n, xp_u64* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_CY);
    if (SUCCEEDED(hr))
        *px = v.cyVal.int64 / 10000;
    return hr;
}

template <class T, class U>
HRESULT get_Property(T* p, U n, xp_array** ppsa)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
    {
        if ((v.vt & VT_ARRAY) == VT_ARRAY)
            *ppsa = v.parray;
        else
            hr = DISP_E_TYPEMISMATCH;
    }
    return hr;
}

// double and date are the same type...

template <class T, class U>
HRESULT get_PropertyDouble(T* p, U n, xp_double* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_R8);
    if (SUCCEEDED(hr))
        *px = v.dblVal;
    return hr;
}

template <class T, class U>
HRESULT get_PropertyDate(T* p, U n, xp_date* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_DATE);
    if (SUCCEEDED(hr))
        *px = v.date;
    return hr;
}

template <class T, class U>
HRESULT get_Property(T* p, U n, BSTR* px)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_BSTR);
    if (SUCCEEDED(hr))
        *px = v.bstrVal;
    return hr;
}

template <class T, class U, class V>
HRESULT get_Property(T* p, U n, const IID& iid /* xp_uuidof(V) */, V** ppx)
{
    VARIANT v;
    v.vt = VT_EMPTY;
    HRESULT hr = p->get_Property(n, &v);
    if (SUCCEEDED(hr))
        hr = AccVarChangeType(&v, &v, VT_DISPATCH);
    if (SUCCEEDED(hr) && v.pdispVal)
    {
        hr = v.pdispVal->QueryInterface(iid, (void**)ppx);
        if (SUCCEEDED(hr))
            v.pdispVal->Release();
    }
    return hr;
}

template <class T, class U>
HRESULT test_Property(T* p, U n)
{
    xp_int x;
    HRESULT hr = get_Property(p, n, &x);
    if (hr == S_OK && x == 0)
        hr = S_FALSE;
    return hr;
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_kvariant x)
{
    return p->put_Property(n, x);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_bool x)
{
    VARIANT v;
    v.vt = VT_BOOL;
    v.boolVal = x ? VARIANT_TRUE : VARIANT_FALSE;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_s32 x)
{
    VARIANT v;
    v.vt = VT_I4;
    v.lVal = x;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_u32 x)
{
    VARIANT v;
    v.vt = VT_UI4;
    v.ulVal = x;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_s64 x)
{
    VARIANT v;
    v.vt = VT_CY;
    v.cyVal.int64 = x * 10000;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_u64 x)
{
    VARIANT v;
    v.vt = VT_CY;
    v.cyVal.int64 = x * 10000;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_kstr x)
{
    VARIANT v;
    v.vt = VT_BSTR;
    v.bstrVal = const_cast<xp_str>(x);
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, IDispatch* x)
{
    VARIANT v;
    v.vt = VT_DISPATCH;
    v.pdispVal = x;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, IUnknown* x)
{
    VARIANT v;
    v.vt = VT_UNKNOWN;
    v.punkVal = x;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_Property(T* p, U n, xp_array* x)
{
    VARIANT v;
    v.vt = VT_ARRAY | VT_VARIANT;
    v.parray = x;
    return p->put_Property(n, v);
}

// xp_date and xp_double are the same...

template <class T, class U>
HRESULT put_PropertyDouble(T* p, U n, xp_double x)
{
    VARIANT v;
    v.vt = VT_R8;
    v.dblVal = x;
    return p->put_Property(n, v);
}

template <class T, class U>
HRESULT put_PropertyDate(T* p, U n, xp_date x)
{
    VARIANT v;
    v.vt = VT_DATE;
    v.date = x;
    return p->put_Property(n, v);
}

XP_END_NAMESPACE()
}
#endif
#endif
